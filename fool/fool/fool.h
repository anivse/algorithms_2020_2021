#ifndef FOOL_H_INCLUDED_
#define FOOL_H_INCLUDED_
#pragma once
#include <stdio.h>
/**
 * @mainpage Introduction
 * Fool - статическая библиотека, содержащая функции для работы с нечеткой логикой.
 */

/**
* TYPES AND FUNCTIONS
*
* @{
*
*/
/**
* @brief Нечеткий логический тип "foozy bool" .
* 
* Данный тип создан на основе значения типа double, которое должно входить в промежуток [0;1].
*/
typedef double fool_t;

/**
* @brief Cоздать из типа int.
* 
* Любое значение, не равное нулю есть единица.
* 
* @param value значение типа int
* @return 0 если параметр равен 0, 1 если параметр - любое другое значение типа int 
*/
fool_t FoolFromInt(int value);

/**
* @brief Cоздать из типа double.
*
* Если параметр принадлежит отрезку от 0 до 1, возвращается то же самое значение, 
* приведенное к типу fool_t. В противном случае программа выдаст ошибку.
*
* @param value значение типа double
* @return значение типа fool_t если параметр принадлежит отрезку от 0 до 1, в
* противном случае -2
*/
fool_t FoolFromDouble(double value);

/**
* @brief Преобразовать к типу int. 
* 
* Если в качестве параметра передано некорректное значение (меньшее 0 или большее 1),
* программа выдает ошибку.
* 
* @param fool значение типа fool_t 
* @return 0 если в качестве параметра передано значение из промежутка от 0 до 0.5, 
* 1 если в качестве парметра передано значение от 0.5 (включительно) до 1, -2 если
* в качестве параметра передано некорректное значение
*/
int FoolAsInt(fool_t fool);

/**
* @brief Преобразовать к типу double. 
* 
* Явное приведение параметра к типу double.
* Если в качестве параметра передано некорректное значение (меньшее 0 или большее 1),
* программа выдает ошибку.
* 
* @param fool значение типа fool_t 
* @return значение типа double в общем случае и -2, если в качестве параметра передано некорректное значение
*/
double FoolAsDouble(fool_t fool);

/**
* @brief Создать по строке.
* 
* Если подстрока, на основе которой можно получить значение типа fool_t не найдена, то
* программа выдает ошибку.
* 
* @param str[] - указатель на строку в формате "fool[0.25]"
* @return значение типа fool_t в общем случае и -2, если подстрока, на основе которой можно 
* получить значение типа fool_t не найдена
*/
fool_t FoolParse(char str[]);

/**
* @brief Записать в строковый буфер.
* 
* На основе значения типа fool_t создается строка в формате "fool[0.25]".
* Если в качестве параметра передано некорректное значение (меньшее 0 или большее 1),
* программа выдает ошибку.
* 
* @param fool значение типа fool_t
* @return указатель на строку в общем случае и -2, если в качестве параметра передано некорректное
* значение
*/
char* FoolFormat(fool_t fool);

/**
* @brief Создать из потока.
* 
* На основе данных из потока создается строка в формате "fool[0.25]", на основе которой создается 
* значение типа fool_t с помощью функции FoolParse.
* Если подстрока, на основе которой можно получить значение типа fool_t не найдена, то
* программа выдает ошибку.
* 
* @param file указатель на поток
* @return значение типа fool_t в общем случае и -2, если подстрока, на основе которой можно 
* получить значение типа fool_t не найдена
* @see FoolParse
*/
fool_t FoolRead(FILE* file);

/**
* @brief Записать в поток в текстовом виде.
* 
* Значение типа fool_t печатается в поток в формате "fool[0.25]".
* Если в качестве параметра передано некорректное значение (меньшее 0 или большее 1),
* программа выдает ошибку.
* 
* @param file указатель на поток
* @param fool значение типа fool_t 
*/
void FoolWrite(FILE* file,fool_t fool);

/**
* @brief Выполнить операцию конъюкции.
* 
* Логическая конъюкция нечетких высказываний.
* Если в качестве одного из (или обоих) параметров передано некорректное значение
* (меньшее 0 или большее 1), программа выдает ошибку.
* 
* @param foolOne значение типа fool_t
* @param foolTwo значение типа fool_t
* @return результат выполнения операции конъюкции - значение типа fool_t и -2, если в качестве одного 
* из (или обоих) параметров передано некорректное значение
*/
fool_t FoolAnd(fool_t foolOne, fool_t foolTwo);

/**
* @brief Выполнить операцию дизъюнкции.
*
* Логическая дизъюнкция нечетких высказываний.
* Если в качестве одного из (или обоих) параметров передано некорректное значение
* (меньшее 0 или большее 1), программа выдает ошибку.
*
* @param foolOne значение типа fool_t
* @param foolTwo значение типа fool_t
* @return результат выполнения операции дизъюнкции - значение типа fool_t и -2, если в качестве одного
* из (или обоих) параметров передано некорректное значение
*/
fool_t FoolOr(fool_t foolOne, fool_t foolTwo);

/**
* @brief Выполнить операцию отрицания.
*
* Логическое отрицание нечетких высказываний.
* Если в качестве параметра передано некорректное значение (меньшее 0 или большее 1),
* программа выдает ошибку.
*
* @param fool значение типа , если в качестве
* параметра передано некорректное значение
* @return результат выполнения операции отрицания - значение типа fool_t и -2, если в качестве
* параметра передано некорректное значение
*/
fool_t FoolNot(fool_t fool);

/**
* @brief Сравнение.
* 
* Если в качестве одного из (или обоих) параметров передано некорректное значение
* (меньшее 0 или большее 1), программа выдает ошибку.
* 
* @param foolOne значение типа fool_t
* @param foolTwo значение типа fool_t
* @return результат выполнения сравнения: –1, 0 или +1 когда первый аргумент меньше, 
* равен или больше второго соответственно, а также -2, если в качестве одного
* из (или обоих) параметров передано некорректное значение 
*/
int FoolCompare(fool_t foolOne, fool_t foolTwo);      
/**@}*/
#endif //FOOL_H_INCLUDED_